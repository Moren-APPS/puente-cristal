<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Prueba de Seguimiento de Manos con Objeto Interactivo</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <style>
        body { margin: 0; font-family: sans-serif; background-color: #222; overflow: hidden; }
        #container { position: relative; width: 100vw; height: 100vh; display: flex; justify-content: center; align-items: center; }
        video, canvas { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%) scaleX(-1); max-width: 100%; max-height: 100%; border-radius: 10px; }
        #overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.8); color: white; display: flex; flex-direction: column; justify-content: center; align-items: center; text-align: center; z-index: 10; padding: 20px; box-sizing: border-box; }
        h1 { font-size: 1.5em; margin-bottom: 20px; }
        button { padding: 15px 30px; font-size: 1.2em; background-color: #007BFF; color: white; border: none; border-radius: 10px; cursor: pointer; font-weight: bold; }
        #loading { display: none; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: white; font-size: 1.5em; background-color: rgba(0,0,0,0.7); padding: 20px; border-radius: 10px; }
        #errorMessage { display: none; color: #f87171; margin-top: 20px; max-width: 80%; }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>

<body>
    <div id="overlay">
        <h1>Mueve el Objeto Virtual</h1>
        <p>Usa tu índice y pulgar para "agarrar" y mover el círculo rojo.</p>
        <button id="startButton">Iniciar Detección</button>
        <p id="errorMessage"></p>
    </div>

    <div id="container">
        <video id="webcam" style="display: none;" playsinline></video>
        <canvas id="outputCanvas"></canvas>
        <div id="loading">Cargando modelos de IA...</div>
    </div>

    <script>
        const startButton = document.getElementById('startButton');
        const overlay = document.getElementById('overlay');
        const videoElement = document.getElementById('webcam');
        const canvasElement = document.getElementById('outputCanvas');
        const canvasCtx = canvasElement.getContext('2d');
        const loadingElement = document.getElementById('loading');
        const errorElement = document.getElementById('errorMessage');

        let hands;
        let animationFrameId;

        // **NUEVO: Definición del objeto virtual y su estado**
        const draggableCircle = {
            x: 300, // Posición inicial en X
            y: 300, // Posición inicial en Y
            radius: 30,
            color: 'red'
        };
        let isGrabbing = false; // Estado para saber si el objeto está siendo agarrado

        // **NUEVO: Función para dibujar nuestro objeto virtual**
        function drawCircle(ctx, circle) {
            ctx.beginPath();
            ctx.arc(circle.x, circle.y, circle.radius, 0, 2 * Math.PI);
            ctx.fillStyle = circle.color;
            ctx.fill();
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 3;
            ctx.stroke();
        }
        
        // **NUEVO: Función para detectar el gesto de "pinza"**
        // Comprueba si la distancia entre el pulgar y el índice es pequeña
        function isPinched(landmarks) {
            const thumbTip = landmarks[4];  // Punta del pulgar
            const indexTip = landmarks[8];  // Punta del índice
            const distance = Math.hypot(thumbTip.x - indexTip.x, thumbTip.y - indexTip.y);
            return distance < 0.05; // Umbral de distancia, puedes ajustarlo
        }


        function onResults(results) {
            if (loadingElement.style.display !== 'none') {
                loadingElement.style.display = 'none';
            }

            canvasElement.width = videoElement.videoWidth;
            canvasElement.height = videoElement.videoHeight;
            
            canvasCtx.save();
            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
            canvasCtx.drawImage(videoElement, 0, 0, canvasElement.width, canvasElement.height);
            
            // **Lógica de Interacción Principal**
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                // Usamos solo la primera mano detectada para la interacción
                const landmarks = results.multiHandLandmarks[0];

                // Convertir coordenadas normalizadas a píxeles del canvas
                const indexTipX = landmarks[8].x * canvasElement.width;
                const indexTipY = landmarks[8].y * canvasElement.height;

                // Dibujar los puntos y conexiones de la mano
                drawConnectors(canvasCtx, landmarks, HAND_CONNECTIONS, { color: '#00FF00', lineWidth: 5 });
                drawLandmarks(canvasCtx, landmarks, { color: '#FF0000', lineWidth: 2 });
                
                const pinched = isPinched(landmarks);
                
                // Calcular la distancia entre la punta del dedo y el centro del círculo
                const distFromCircle = Math.hypot(indexTipX - draggableCircle.x, indexTipY - draggableCircle.y);

                // **AGARRAR**: Si no estamos agarrando, hacemos la pinza y estamos cerca del círculo
                if (!isGrabbing && pinched && distFromCircle < draggableCircle.radius * 2) {
                   isGrabbing = true;
                }
                
                // **SOLTAR**: Si estamos agarrando y dejamos de hacer la pinza
                if (isGrabbing && !pinched) {
                    isGrabbing = false;
                }
                
                // **MOVER**: Si estamos en estado de "agarrando", actualizamos la posición del círculo
                if (isGrabbing) {
                    draggableCircle.x = indexTipX;
                    draggableCircle.y = indexTipY;
                }
                
            } else {
                // Si no se detectan manos, nos aseguramos de soltar el objeto
                isGrabbing = false;
            }
            
            // **Dibujar el círculo virtual en cada fotograma**
            drawCircle(canvasCtx, draggableCircle);

            canvasCtx.restore();
        }

        async function startApp() {
            overlay.style.display = 'none';
            loadingElement.style.display = 'block';

            try {
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: { width: 1280, height: 720 }
                });
                videoElement.srcObject = stream;
                videoElement.play();

                videoElement.onloadedmetadata = () => {
                    hands = new Hands({locateFile: (file) => {
                        return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
                    }});
                    
                    hands.setOptions({
                        maxNumHands: 1, // Cambiado a 1 para simplificar la interacción
                        modelComplexity: 1,
                        minDetectionConfidence: 0.5,
                        minTrackingConfidence: 0.5
                    });
                    
                    hands.onResults(onResults);
                    sendToHands();
                };

            } catch (err) {
                loadingElement.style.display = 'none';
                overlay.style.display = 'flex';
                errorElement.style.display = 'block';
                errorElement.textContent = `Error al iniciar la cámara: ${err.message}. Asegúrate de haber dado permiso.`;
                console.error(err);
            }
        }
        
        async function sendToHands() {
            if (!videoElement.paused && !videoElement.ended) {
                await hands.send({ image: videoElement });
            }
            animationFrameId = requestAnimationFrame(sendToHands);
        }

        startButton.addEventListener('click', startApp);
    </script>
</body>
</html>