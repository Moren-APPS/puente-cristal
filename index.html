<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Puente de Cristal AR</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- MEJORA: Se añade OrbitControls para el modo 3D -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <style>
        body { margin: 0; overflow: hidden; font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; background-color: #000; }
        #overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.7); color: white; display: flex; flex-direction: column; justify-content: center; align-items: center; text-align: center; z-index: 10; padding: 20px; box-sizing: border-box; transition: opacity 0.5s ease; }
        .content { background-color: rgba(20, 20, 20, 0.8); padding: 30px; border-radius: 15px; box-shadow: 0 0 20px rgba(255, 0, 150, 0.5); border: 1px solid rgba(255, 0, 150, 0.7); }
        h1 { font-size: 2.5em; margin-bottom: 10px; color: #FF0096; text-shadow: 0 0 10px #FF0096; }
        p { font-size: 1.2em; margin-bottom: 25px; }
        button { padding: 15px 30px; font-size: 1.2em; background-color: #FF0096; color: white; border: none; border-radius: 10px; cursor: pointer; text-transform: uppercase; font-weight: bold; transition: all 0.3s ease; box-shadow: 0 0 15px #FF0096; }
        #message { position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); background-color: rgba(0,0,0,0.8); color: white; padding: 10px 20px; border-radius: 10px; font-size: 1.2em; z-index: 5; display: none; border: 1px solid #FF0096; max-width: 90%; text-align: center; }
        #entry-button { position: absolute; bottom: 20px; right: 20px; padding: 12px 24px; border: 1px solid #fff; border-radius: 4px; background: rgba(0,0,0,0.4); color: #fff; font: 16px sans-serif; z-index: 100; cursor: pointer; }
    </style>
</head>
<body>
    <div id="overlay">
        <div class="content">
            <h1>Puente de Cristal AR</h1>
            <p>Comprueba si tu dispositivo es compatible con AR o juega en modo 3D.</p>
            <button id="startButton">Comenzar</button>
        </div>
    </div>
    <div id="message"></div>

    <script>
        if (window.location.protocol !== 'https:') {
            document.body.innerHTML = `<div id="overlay"><div class="content"><h1 style="color: #ff4d4d;">Error de Seguridad</h1><p>Esta experiencia requiere una conexión segura (HTTPS).</p></div></div>`;
        }

        let scene, camera, renderer, raycaster, controller, controls;
        let bridge, reticle;
        let hitTestSource = null;
        let gameActive = false;
        let bridgePlaced = false;
        let currentRow = 0;
        const bridgeRows = 8;
        let shatteredFragments = [];
        let isARMode = false;

        const startButton = document.getElementById('startButton');
        const overlay = document.getElementById('overlay');
        const message = document.getElementById('message');

        startButton.addEventListener('click', init);

        async function init() {
            overlay.style.opacity = '0';
            setTimeout(() => { overlay.style.display = 'none'; }, 500);

            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            
            const ambientLight = new THREE.AmbientLight(0xffffff, 1.0);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(5, 10, 7.5);
            scene.add(directionalLight);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);
            
            const entryButton = document.createElement('button');
            entryButton.id = 'entry-button';
            document.body.appendChild(entryButton);
            
            // MEJORA: Comprobar compatibilidad con WebXR
            if (navigator.xr) {
                const isSupported = await navigator.xr.isSessionSupported('immersive-ar');
                if (isSupported) {
                    isARMode = true;
                    entryButton.textContent = 'ENTRAR EN AR';
                    entryButton.onclick = startARSession;
                } else {
                    entryButton.textContent = 'JUGAR EN 3D';
                    entryButton.onclick = start3DMode;
                }
            } else {
                entryButton.textContent = 'JUGAR EN 3D';
                entryButton.onclick = start3DMode;
            }

            raycaster = new THREE.Raycaster();
            window.addEventListener('resize', onWindowResize);
            renderer.setAnimationLoop(render);
        }

        function start3DMode() {
            document.getElementById('entry-button').style.display = 'none';
            renderer.setAnimationLoop(render);
            
            scene.background = new THREE.Color(0x111827);
            camera.position.set(0, 2, 4);
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.target.set(0, 0, -2);
            controls.update();

            bridge = setupBridge();
            scene.add(bridge);
            bridgePlaced = true;
            gameActive = true;
            
            window.addEventListener('click', handle3DInteraction);
        }
        
        async function startARSession() {
            try {
                const session = await navigator.xr.requestSession('immersive-ar', { requiredFeatures: ['hit-test'] });
                renderer.xr.enabled = true;
                renderer.xr.setSession(session);
                document.getElementById('entry-button').style.display = 'none';
                onSessionStarted(session);
            } catch (e) {
                console.error("No se pudo iniciar la sesión de AR:", e);
                showMessage("No se pudo iniciar la sesión de AR.", true);
            }
        }
        
        async function onSessionStarted(session) {
            session.addEventListener('end', () => window.location.reload());
            controller = renderer.xr.getController(0);
            controller.addEventListener('select', onSelectAR);
            scene.add(controller);

            reticle = new THREE.Mesh(new THREE.RingGeometry(0.05, 0.07, 32).rotateX(-Math.PI / 2), new THREE.MeshBasicMaterial());
            reticle.matrixAutoUpdate = false;
            reticle.visible = false;
            scene.add(reticle);

            const viewerSpace = await session.requestReferenceSpace('viewer');
            hitTestSource = await session.requestHitTestSource({ space: viewerSpace });
        }

        function onSelectAR() {
            if (reticle.visible && !bridgePlaced) {
                bridge = setupBridge();
                bridge.position.setFromMatrixPosition(reticle.matrix);
                scene.add(bridge);
                bridgePlaced = true;
                reticle.visible = false;
                gameActive = true;
            } else if (bridgePlaced && gameActive) {
                const tempMatrix = new THREE.Matrix4().identity().extractRotation(controller.matrixWorld);
                raycaster.ray.origin.setFromMatrixPosition(controller.matrixWorld);
                raycaster.ray.direction.set(0, 0, -1).applyMatrix4(tempMatrix);
                const intersects = raycaster.intersectObjects(bridge.children.filter(c => c.isSquare));
                if (intersects.length > 0) handleInteraction(intersects[0].object);
            }
        }
        
        function handle3DInteraction(event) {
            const mouse = new THREE.Vector2();
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(bridge.children.filter(c => c.isSquare));
            if (intersects.length > 0) handleInteraction(intersects[0].object);
        }
        
        function setupBridge() {
            const bridgeGroup = new THREE.Group();
            const squareSize = 0.5;
            const gap = 0.1;
            for (let i = 0; i < bridgeRows; i++) {
                const safeIndex = Math.round(Math.random());
                for (let j = 0; j < 2; j++) {
                    const geometry = new THREE.BoxGeometry(squareSize, 0.05, squareSize);
                    const material = new THREE.MeshStandardMaterial({ color: 0xffffff, transparent: true, opacity: 0.4, metalness: 0.1, roughness: 0.2 });
                    const square = new THREE.Mesh(geometry, material);
                    square.position.z = -(i * (squareSize + gap));
                    square.position.x = (j * (squareSize + gap)) - (squareSize / 2 + gap/2);
                    square.isSquare = true; square.isSafe = (j === safeIndex); square.row = i;
                    bridgeGroup.add(square);
                }
            }
            return bridgeGroup;
        }

        function handleInteraction(clickedMesh) {
            if (gameActive && clickedMesh.row === currentRow) {
                if (clickedMesh.isSafe) {
                    clickedMesh.material.color.setHex(0x00ff00);
                    clickedMesh.material.opacity = 0.9;
                    currentRow++;
                    if (currentRow >= bridgeRows) endGame(true);
                } else {
                    shatterSquare(clickedMesh);
                    endGame(false);
                }
            }
        }

        function shatterSquare(mesh) {
            mesh.visible = false;
            const numFragments = 16;
            const fragmentMaterial = new THREE.MeshStandardMaterial({ color: 0xffffff, metalness: 0.1, roughness: 0.5 });
            const worldPosition = new THREE.Vector3();
            mesh.getWorldPosition(worldPosition);
            for (let i = 0; i < numFragments; i++) {
                const fragment = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.05, 0.1), fragmentMaterial);
                fragment.position.copy(worldPosition);
                const velocity = new THREE.Vector3((Math.random() - 0.5) * 0.5, Math.random() * 0.5, (Math.random() - 0.5) * 0.5);
                shatteredFragments.push({ mesh: fragment, velocity: velocity, lifetime: 120 });
                scene.add(fragment);
            }
        }
        
        // MEJORA: Lógica de reinicio sin recargar la página
        function resetGame() {
            overlay.style.opacity = '0';
            setTimeout(() => { overlay.style.display = 'none'; }, 500);
            
            scene.remove(bridge);
            shatteredFragments.forEach(f => scene.remove(f.mesh));
            shatteredFragments = [];
            
            bridge = setupBridge();
            if(isARMode && reticle.visible){
                 bridge.position.setFromMatrixPosition(reticle.matrix);
            }
            scene.add(bridge);
            
            currentRow = 0;
            gameActive = true;
        }

        function endGame(isWin) {
            gameActive = false;
            showMessage(isWin ? "¡Felicidades, has cruzado!" : "¡Juego Terminado! Has caído.", !isWin);
            setTimeout(() => {
                overlay.style.display = 'flex';
                overlay.style.opacity = '1';
                document.querySelector('#overlay h1').textContent = isWin ? '¡Has Ganado!' : '¡Juego Terminado!';
                document.querySelector('#overlay p').textContent = '¿Quieres jugar de nuevo?';
                const restartButton = document.getElementById('startButton');
                restartButton.textContent = 'Reiniciar Juego';
                restartButton.onclick = resetGame; // <-- Llama a la nueva función de reinicio
            }, 3000);
        }
        
        function render(timestamp, frame) {
            if (isARMode && frame) {
                if (hitTestSource && !bridgePlaced) {
                    const hitTestResults = frame.getHitTestResults(hitTestSource);
                    if (hitTestResults.length) {
                        const hit = hitTestResults[0];
                        const referenceSpace = renderer.xr.getReferenceSpace();
                        reticle.visible = true;
                        reticle.matrix.fromArray(hit.getPose(referenceSpace).transform.matrix);
                    } else {
                        reticle.visible = false;
                    }
                }
            }
            
            for (let i = shatteredFragments.length - 1; i >= 0; i--) {
                const f = shatteredFragments[i];
                f.mesh.position.addScaledVector(f.velocity, 0.016);
                f.velocity.y -= 0.01;
                f.lifetime--;
                if (f.lifetime <= 0) {
                    scene.remove(f.mesh);
                    shatteredFragments.splice(i, 1);
                }
            }
            if(controls) controls.update();
            renderer.render(scene, camera);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        function showMessage(text, isError = false) { 
            const msgEl = document.getElementById('message');
            msgEl.textContent = text; 
            msgEl.style.backgroundColor = isError ? 'rgba(200, 0, 0, 0.8)' : 'rgba(0,0,0,0.7)'; 
            msgEl.style.display = 'block'; 
            setTimeout(() => { msgEl.style.display = 'none'; }, 3000);
        }
    </script>
</body>
</html>

