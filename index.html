<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Pizarra Virtual (Multijugador Estable)</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <style>
        body { margin: 0; font-family: sans-serif; background-color: #222; overflow: hidden; }
        #container { position: relative; width: 100vw; height: 100vh; display: flex; justify-content: center; align-items: center; }
        video, canvas { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%) scaleX(-1); max-width: 100%; max-height: 100%; border-radius: 10px; }
        canvas { background-color: transparent; }
        #outputCanvas { z-index: 2; }
        #drawingCanvas { z-index: 1; }
        #webcam { z-index: 0; }
        #overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.8); color: white; display: flex; flex-direction: column; justify-content: center; align-items: center; text-align: center; z-index: 10; padding: 20px; box-sizing: border-box; }
        h1 { font-size: 1.5em; margin-bottom: 20px; }
        p { max-width: 80%; line-height: 1.5; }
        button { padding: 15px 30px; font-size: 1.2em; background-color: #007BFF; color: white; border: none; border-radius: 10px; cursor: pointer; font-weight: bold; }
        #loading { display: none; z-index: 5; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: white; font-size: 1.5em; background-color: rgba(0,0,0,0.7); padding: 20px; border-radius: 10px; }
        #switchCameraButton { display: none; position: absolute; bottom: 20px; right: 20px; z-index: 100; padding: 10px 15px; font-size: 1.5em; background-color: rgba(0, 0, 0, 0.5); border: 2px solid white; border-radius: 50%; cursor: pointer; }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>
    <div id="overlay">
        <h1>Pizarra Virtual Final</h1>
        <p>Usa los íconos para cambiar herramientas y colores. <br>¡Ahora pueden dibujar hasta dos personas a la vez!</p>
        <button id="startButton">Iniciar Pizarra</button>
    </div>
    <div id="container">
        <video id="webcam" playsinline></video>
        <canvas id="drawingCanvas"></canvas>
        <canvas id="outputCanvas"></canvas>
        <div id="loading">Cargando modelos de IA...</div>
        <button id="switchCameraButton">🔄</button>
    </div>
    <script>
        const startButton = document.getElementById('startButton');
        const overlay = document.getElementById('overlay');
        const videoElement = document.getElementById('webcam');
        const outputCanvas = document.getElementById('outputCanvas');
        const outputCtx = outputCanvas.getContext('2d');
        const drawingCanvas = document.getElementById('drawingCanvas');
        const drawingCtx = drawingCanvas.getContext('2d');
        const switchCameraButton = document.getElementById('switchCameraButton');
        const loadingElement = document.getElementById('loading');
        let hands, activeStream;
        let handsInitialized = false;
        const smoothingFactor = 0.4;
        const eraserSize = 60;
        let currentFacingMode = 'user';
        let touchCooldown = 0;
        
        // --- CAMBIO: El estado ahora es un array de jugadores ---
        let players = [];

        const paletteIcon = { x: 30, y: 30, width: 60, height: 60, emoji: '🎨' };
        const thicknessIcon = { x: 30, y: 110, width: 60, height: 60 };
        const clearButton = { x: 0, y: 30, width: 60, height: 60, emoji: '🗑️' };
        const colors = ['#FF1744', '#00E676', '#2979FF', '#FFFF00', '#FFFFFF', '#000000'];
        let isPaletteOpen = false;
        let colorSwatches = [];
        const thicknessOptions = [4, 10, 20];
        let currentLineWidth = 10;
        let isThicknessMenuOpen = false;
        let thicknessSwatches = [];
        
        function isPointInsideRect(point, rect) { return point.x > rect.x && point.x < rect.x + rect.width && point.y > rect.y && point.y < rect.y + rect.height; }
        
        function drawUI(ctx, point) { /* ... sin cambios ... */ }
        function drawPencilCursor(ctx, centerPos) { /* ... sin cambios ... */ }

        function onResults(results) {
            outputCtx.save();
            outputCtx.clearRect(0, 0, outputCanvas.width, outputCanvas.height);
            
            const interactionPoint = players[0]?.state.smoothedPoint || {x: -100, y: -100};
            drawUI(outputCtx, interactionPoint);

            // --- LÓGICA DE RASTREO POR PROXIMIDAD ---
            const newHandsData = [];
            if (results.multiHandLandmarks) {
                results.multiHandLandmarks.forEach((landmarks, i) => {
                    // Guarda la posición central de la nueva mano detectada
                    newHandsData.push({
                        landmarks: landmarks,
                        center: { x: landmarks[9].x, y: landmarks[9].y }
                    });
                });
            }

            const matchedPlayers = [];
            const unmatchedHands = [...newHandsData];
            const unmatchedPlayers = [...players];

            // Intenta emparejar jugadores existentes con las manos detectadas más cercanas
            unmatchedPlayers.forEach(player => {
                let closestHandIndex = -1;
                let minDistance = 0.1; // Umbral de distancia para considerar un emparejamiento

                unmatchedHands.forEach((hand, index) => {
                    const distance = Math.hypot(hand.center.x - player.lastCenter.x, hand.center.y - player.lastCenter.y);
                    if (distance < minDistance) {
                        minDistance = distance;
                        closestHandIndex = index;
                    }
                });

                if (closestHandIndex !== -1) {
                    player.update(unmatchedHands[closestHandIndex].landmarks);
                    matchedPlayers.push(player);
                    unmatchedHands.splice(closestHandIndex, 1);
                }
            });

            // Asigna las manos no emparejadas a nuevos jugadores
            unmatchedHands.forEach(hand => {
                const newPlayer = new Player(hand.landmarks);
                matchedPlayers.push(newPlayer);
            });
            
            players = matchedPlayers; // Actualiza la lista de jugadores activos

            // --- LÓGICA DE DIBUJO Y PROCESAMIENTO POR JUGADOR ---
            players.forEach((player, index) => {
                player.process(); // Calcula posiciones suavizadas, etc.
                
                // Asigna un nombre de jugador basado en el orden en que aparecen ahora
                const playerLabel = `Jugador ${index + 1}`;
                const wrist = player.landmarks[0];
                const wristX = wrist.x * outputCanvas.width;
                const wristY = wrist.y * outputCanvas.height;
                outputCtx.fillStyle = 'white';
                outputCtx.font = 'bold 24px sans-serif';
                outputCtx.textAlign = 'center';
                outputCtx.fillText(playerLabel, wristX, wristY - 30);
                
                player.drawHand(); // Dibuja el esqueleto
                player.handleActions(); // Dibuja, borra e interactúa con la UI
            });

            outputCtx.restore();
        }

        // --- NUEVO: Clase para manejar el estado de cada jugador ---
        class Player {
            constructor(landmarks) {
                this.landmarks = landmarks;
                this.lastCenter = { x: landmarks[9].x, y: landmarks[9].y };
                this.state = {
                    lastPosition: null, isFirstFrame: true,
                    smoothedPoint: { x: 0, y: 0 }, smoothedMidpoint: { x: 0, y: 0 },
                    smoothedPencilTip: { x: 0, y: 0 }
                };
            }
            
            update(landmarks) {
                this.landmarks = landmarks;
                this.lastCenter = { x: landmarks[9].x, y: landmarks[9].y };
            }

            process() {
                const indexTip = this.landmarks[8];
                const thumbTip = this.landmarks[4];
                const currentPoint = { x: indexTip.x * outputCanvas.width, y: indexTip.y * outputCanvas.height };
                const midpointX = ((thumbTip.x + indexTip.x) / 2) * outputCanvas.width;
                const midpointY = ((thumbTip.y + indexTip.y) / 2) * outputCanvas.height;
                if (this.state.isFirstFrame) {
                    this.state.smoothedPoint.x = currentPoint.x; this.state.smoothedPoint.y = currentPoint.y;
                    this.state.smoothedMidpoint.x = midpointX; this.state.smoothedMidpoint.y = midpointY;
                    this.state.smoothedPencilTip.x = midpointX; this.state.smoothedPencilTip.y = midpointY;
                    this.state.isFirstFrame = false;
                }
                this.state.smoothedPoint.x += (currentPoint.x - this.state.smoothedPoint.x) * smoothingFactor;
                this.state.smoothedPoint.y += (currentPoint.y - this.state.smoothedPoint.y) * smoothingFactor;
                this.state.smoothedMidpoint.x += (midpointX - this.state.smoothedMidpoint.x) * smoothingFactor;
                this.state.smoothedMidpoint.y += (midpointY - this.state.smoothedMidpoint.y) * smoothingFactor;
                const pencilAngle = Math.PI / 4;
                const pencilHalfLength = 90 / 2;
                const rawTipX = this.state.smoothedMidpoint.x + pencilHalfLength * Math.cos(pencilAngle);
                const rawTipY = this.state.smoothedMidpoint.y + pencilHalfLength * Math.sin(pencilAngle);
                this.state.smoothedPencilTip.x += (rawTipX - this.state.smoothedPencilTip.x) * smoothingFactor;
                this.state.smoothedPencilTip.y += (rawTipY - this.state.smoothedPencilTip.y) * smoothingFactor;
            }

            drawHand() {
                drawConnectors(outputCtx, this.landmarks, HAND_CONNECTIONS, { color: '#00FF00', lineWidth: 5 });
                drawLandmarks(outputCtx, this.landmarks, { color: '#FFFFFF', lineWidth: 2, radius: 3 });
            }

            handleActions() {
                let fingerOnUI = false;
                if (touchCooldown > 0) touchCooldown--;
                if (isPaletteOpen) { for (const swatch of colorSwatches) { if (isPointInsideRect(this.state.smoothedPoint, swatch) && touchCooldown === 0) { drawingCtx.strokeStyle = swatch.color; isPaletteOpen = false; touchCooldown = 20; fingerOnUI = true; break; } } } else if (isThicknessMenuOpen) { for (const swatch of thicknessSwatches) { if (isPointInsideRect(this.state.smoothedPoint, swatch) && touchCooldown === 0) { currentLineWidth = swatch.size; drawingCtx.lineWidth = currentLineWidth; isThicknessMenuOpen = false; touchCooldown = 20; fingerOnUI = true; break; } } }
                if (!fingerOnUI && touchCooldown === 0) { if (isPointInsideRect(this.state.smoothedPoint, clearButton)) { drawingCtx.clearRect(0, 0, drawingCanvas.width, drawingCanvas.height); touchCooldown = 20; fingerOnUI = true; } else if (isPointInsideRect(this.state.smoothedPoint, paletteIcon)) { isPaletteOpen = !isPaletteOpen; isThicknessMenuOpen = false; touchCooldown = 20; fingerOnUI = true; } else if (isPointInsideRect(this.state.smoothedPoint, thicknessIcon)) { isThicknessMenuOpen = !isThicknessMenuOpen; isPaletteOpen = false; touchCooldown = 20; fingerOnUI = true; } }
                
                if (!fingerOnUI) {
                    const pinched = isPinched(this.landmarks);
                    const openPalm = isOpenPalm(this.landmarks);
                    if (openPalm) {
                        this.state.lastPosition = null;
                        drawingCtx.clearRect(this.state.smoothedPoint.x - eraserSize / 2, this.state.smoothedPoint.y - eraserSize / 2, eraserSize, eraserSize);
                        outputCtx.save();
                        const x = this.state.smoothedPoint.x - eraserSize / 2; const y = this.state.smoothedPoint.y - (eraserSize * 0.6) / 2;
                        outputCtx.fillStyle = 'rgba(255, 105, 180, 0.8)';
                        outputCtx.fillRect(x, y, eraserSize, eraserSize * 0.6);
                        outputCtx.strokeStyle = 'rgba(0, 0, 0, 0.8)';
                        outputCtx.lineWidth = 2;
                        outputCtx.strokeRect(x, y, eraserSize, eraserSize * 0.6);
                        outputCtx.restore();
                    } else if (pinched) {
                        if (this.state.lastPosition) {
                            drawingCtx.beginPath();
                            drawingCtx.moveTo(this.state.lastPosition.x, this.state.lastPosition.y);
                            drawingCtx.lineTo(this.state.smoothedPencilTip.x, this.state.smoothedPencilTip.y);
                            drawingCtx.stroke();
                        }
                        this.state.lastPosition = { x: this.state.smoothedPencilTip.x, y: this.state.smoothedPencilTip.y };
                        drawPencilCursor(outputCtx, this.state.smoothedMidpoint);
                    } else {
                        this.state.lastPosition = null;
                    }
                }
            }
        }

        function resizeCanvases() { const videoWidth = videoElement.videoWidth; const videoHeight = videoElement.videoHeight; if (!videoWidth) return; outputCanvas.width = videoWidth; outputCanvas.height = videoHeight; drawingCanvas.width = videoWidth; drawingCanvas.height = videoHeight; clearButton.x = outputCanvas.width - clearButton.width - 30; drawingCtx.strokeStyle = drawingCtx.strokeStyle || '#00FFFF'; drawingCtx.lineWidth = currentLineWidth; drawingCtx.lineCap = 'round'; drawingCtx.lineJoin = 'round'; }
        
        async function startCamera(facingMode) {
            loadingElement.style.display = 'block';
            if (activeStream) { activeStream.getTracks().forEach(track => track.stop()); }
            const constraints = { video: { width: { ideal: 1280 }, height: { ideal: 720 }, facingMode: { exact: facingMode } } };
            try {
                const stream = await navigator.mediaDevices.getUserMedia(constraints);
                activeStream = stream;
                videoElement.srcObject = stream;
                videoElement.onloadedmetadata = () => {
                    videoElement.play();
                    loadingElement.style.display = 'none';
                    switchCameraButton.style.display = 'block';
                    resizeCanvases();
                    if (!handsInitialized) {
                        hands = new Hands({ locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}` });
                        hands.setOptions({
                            maxNumHands: 2, 
                            modelComplexity: 1,
                            minDetectionConfidence: 0.7,
                            minTrackingConfidence: 0.7
                        });
                        hands.onResults(onResults);
                        sendToHands();
                        handsInitialized = true;
                    }
                };
            } catch (err) {
                loadingElement.style.display = 'none';
                console.error("Error al iniciar/cambiar de cámara:", err);
            }
        }
        
        async function sendToHands() { if (videoElement.readyState >= 3) { await hands.send({ image: videoElement }); } requestAnimationFrame(sendToHands); }
        function isPinched(landmarks) { const thumbTip = landmarks[4]; const indexTip = landmarks[8]; const distance = Math.hypot(thumbTip.x - indexTip.x, thumbTip.y - indexTip.y); return distance < 0.04; }
        function isOpenPalm(landmarks) { let extendedFingers = 0; const fingerTips = [8, 12, 16, 20]; const fingerPips = [6, 10, 14, 18]; for (let i = 0; i < fingerTips.length; i++) { if (landmarks[fingerTips[i]].y < landmarks[fingerPips[i]].y) { extendedFingers++; } } return extendedFingers >= 3; }
        
        startButton.addEventListener('click', () => { overlay.style.display = 'none'; startCamera(currentFacingMode); });
        switchCameraButton.addEventListener('click', () => { currentFacingMode = (currentFacingMode === 'user') ? 'environment' : 'user'; startCamera(currentFacingMode); });
        window.addEventListener('resize', resizeCanvases);
        function drawPencilCursor(ctx, centerPos) { const totalLength = 90; const halfLength = totalLength / 2; const pencilWidth = 14; const tipLength = 15; ctx.save(); ctx.translate(centerPos.x, centerPos.y); ctx.rotate(Math.PI / 4); const bodyStart = -halfLength + 15; const bodyLength = totalLength - 15 - tipLength; const tipStart = bodyStart + bodyLength; ctx.fillStyle = '#FFB6C1'; ctx.fillRect(-halfLength, -pencilWidth / 2, 15, pencilWidth); ctx.fillStyle = '#C0C0C0'; ctx.fillRect(bodyStart - 5, -pencilWidth / 2 - 1, 5, pencilWidth + 2); ctx.fillStyle = '#FFD700'; ctx.fillRect(bodyStart, -pencilWidth / 2, bodyLength, pencilWidth); ctx.fillStyle = '#D2B48C'; ctx.beginPath(); ctx.moveTo(tipStart, -pencilWidth / 2); ctx.lineTo(tipStart + tipLength, 0); ctx.lineTo(tipStart, pencilWidth / 2); ctx.closePath(); ctx.fill(); ctx.fillStyle = '#333333'; ctx.beginPath(); ctx.moveTo(tipStart + tipLength, 0); ctx.lineTo(tipStart + tipLength - 5, -2); ctx.lineTo(tipStart + tipLength - 5, 2); ctx.closePath(); ctx.fill(); ctx.restore(); }
        function drawUI(ctx, point) { const buttonBackgroundColor = 'rgba(0, 0, 0, 0.5)'; ctx.fillStyle = buttonBackgroundColor; ctx.fillRect(paletteIcon.x, paletteIcon.y, paletteIcon.width, paletteIcon.height); ctx.font = '40px sans-serif'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText(paletteIcon.emoji, paletteIcon.x + paletteIcon.width / 2, paletteIcon.y + paletteIcon.height / 2); ctx.fillStyle = buttonBackgroundColor; ctx.fillRect(thicknessIcon.x, thicknessIcon.y, thicknessIcon.width, thicknessIcon.height); ctx.fillStyle = 'white'; ctx.fillRect(thicknessIcon.x + 15, thicknessIcon.y + 15, 30, 3); ctx.fillRect(thicknessIcon.x + 15, thicknessIcon.y + 28, 30, 6); ctx.fillRect(thicknessIcon.x + 15, thicknessIcon.y + 45, 30, 9); ctx.fillStyle = buttonBackgroundColor; ctx.fillRect(clearButton.x, clearButton.y, clearButton.width, clearButton.height); ctx.font = '40px sans-serif'; ctx.fillText(clearButton.emoji, clearButton.x + clearButton.width / 2, clearButton.y + clearButton.height / 2); if (isPaletteOpen) { colorSwatches = []; colors.forEach((color, index) => { const swatch = { x: paletteIcon.x + (index + 1) * (paletteIcon.width + 10), y: paletteIcon.y, width: paletteIcon.width, height: paletteIcon.height, color: color }; colorSwatches.push(swatch); ctx.fillStyle = buttonBackgroundColor; ctx.fillRect(swatch.x, swatch.y, swatch.width, swatch.height); ctx.fillStyle = color; ctx.fillRect(swatch.x + 5, swatch.y + 5, swatch.width - 10, swatch.height - 10); if (isPointInsideRect(point, swatch)) { ctx.strokeStyle = 'cyan'; ctx.lineWidth = 4; ctx.strokeRect(swatch.x, swatch.y, swatch.width, swatch.height); } }); } if (isThicknessMenuOpen) { thicknessSwatches = []; thicknessOptions.forEach((size, index) => { const swatch = { x: thicknessIcon.x + (index + 1) * (thicknessIcon.width + 10), y: thicknessIcon.y, width: thicknessIcon.width, height: thicknessIcon.height, size: size }; thicknessSwatches.push(swatch); ctx.fillStyle = buttonBackgroundColor; ctx.fillRect(swatch.x, swatch.y, swatch.width, swatch.height); ctx.fillStyle = 'white'; ctx.beginPath(); ctx.arc(swatch.x + swatch.width / 2, swatch.y + swatch.height / 2, swatch.size, 0, 2 * Math.PI); ctx.fill(); if (isPointInsideRect(point, swatch)) { ctx.strokeStyle = 'cyan'; ctx.lineWidth = 4; ctx.strokeRect(swatch.x, swatch.y, swatch.width, swatch.height); } }); } }
    </script>
</body>
</html>