<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Puente de Cristal AR</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body { margin: 0; overflow: hidden; font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; background-color: #000; }
        #overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.7); color: white; display: flex; flex-direction: column; justify-content: center; align-items: center; text-align: center; z-index: 10; padding: 20px; box-sizing: border-box; transition: opacity 0.5s ease; }
        .content { background-color: rgba(20, 20, 20, 0.8); padding: 30px; border-radius: 15px; box-shadow: 0 0 20px rgba(255, 0, 150, 0.5); border: 1px solid rgba(255, 0, 150, 0.7); }
        h1 { font-size: 2.5em; margin-bottom: 10px; color: #FF0096; text-shadow: 0 0 10px #FF0096; }
        p { font-size: 1.2em; margin-bottom: 25px; }
        button { padding: 15px 30px; font-size: 1.2em; background-color: #FF0096; color: white; border: none; border-radius: 10px; cursor: pointer; text-transform: uppercase; font-weight: bold; transition: all 0.3s ease; box-shadow: 0 0 15px #FF0096; }
        #message { position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); background-color: rgba(0,0,0,0.8); color: white; padding: 10px 20px; border-radius: 10px; font-size: 1.2em; z-index: 5; display: none; border: 1px solid #FF0096; max-width: 90%; text-align: center; }
        /* Botón para entrar en AR */
        #ar-button { position: absolute; bottom: 20px; right: 20px; padding: 12px 24px; border: 1px solid #fff; border-radius: 4px; background: rgba(0,0,0,0.4); color: #fff; font: 16px sans-serif; z-index: 100; cursor: pointer; }
    </style>
</head>
<body>
    <div id="overlay">
        <div class="content">
            <h1>Puente de Cristal AR</h1>
            <p>Mueve tu teléfono para escanear el suelo.<br>Toca la pantalla para colocar el puente.</p>
            <button id="startButton">Comenzar</button>
        </div>
    </div>
    <div id="message"></div>

    <script>
        if (window.location.protocol !== 'https:') {
            document.body.innerHTML = `<div id="overlay"><div class="content"><h1 style="color: #ff4d4d;">Error de Seguridad</h1><p>La Realidad Aumentada requiere una conexión segura (HTTPS).</p></div></div>`;
        }

        let scene, camera, renderer, raycaster, controller;
        let bridge, reticle;
        let hitTestSource = null;
        let hitTestSourceRequested = false;
        
        let gameActive = false;
        let bridgePlaced = false;
        let currentRow = 0;
        const bridgeRows = 8;
        let shatteredFragments = [];

        const startButton = document.getElementById('startButton');
        const overlay = document.getElementById('overlay');
        const message = document.getElementById('message');

        startButton.addEventListener('click', init);

        async function init() {
            if (!navigator.xr) {
                showMessage("Error: Tu navegador no soporta Realidad Aumentada (WebXR).", true);
                return;
            }
            overlay.style.opacity = '0';
            setTimeout(() => { overlay.style.display = 'none'; }, 500);

            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            
            const ambientLight = new THREE.AmbientLight(0xffffff, 1.0);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(5, 10, 7.5);
            scene.add(directionalLight);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.xr.enabled = true;
            document.body.appendChild(renderer.domElement);
            
            // Botón para entrar en AR
            const arButton = document.createElement('button');
            arButton.id = 'ar-button';
            arButton.textContent = 'ENTRAR EN AR';
            arButton.onclick = async () => {
                try {
                    const session = await navigator.xr.requestSession('immersive-ar', { requiredFeatures: ['hit-test'] });
                    renderer.xr.setSession(session);
                    arButton.style.display = 'none';
                    onSessionStarted(session);
                } catch (e) {
                    console.error("No se pudo iniciar la sesión de AR:", e);
                    showMessage("No se pudo iniciar la sesión de AR. Asegúrate de que tu dispositivo sea compatible.", true);
                }
            };
            document.body.appendChild(arButton);

            raycaster = new THREE.Raycaster();
            
            window.addEventListener('resize', onWindowResize);
        }
        
        async function onSessionStarted(session) {
            session.addEventListener('end', onSessionEnded);

            controller = renderer.xr.getController(0);
            controller.addEventListener('select', onSelect);
            scene.add(controller);

            // Retícula para apuntar al suelo
            reticle = new THREE.Mesh(
                new THREE.RingGeometry(0.05, 0.07, 32).rotateX(-Math.PI / 2),
                new THREE.MeshBasicMaterial()
            );
            reticle.matrixAutoUpdate = false;
            reticle.visible = false;
            scene.add(reticle);

            const viewerSpace = await session.requestReferenceSpace('viewer');
            hitTestSource = await session.requestHitTestSource({ space: viewerSpace });
            
            renderer.setAnimationLoop(render);
        }

        function onSessionEnded() {
            window.location.reload();
        }

        function onSelect() {
            if (reticle.visible && !bridgePlaced) {
                bridge = setupBridge(scene);
                bridge.position.setFromMatrixPosition(reticle.matrix);
                scene.add(bridge);
                bridgePlaced = true;
                reticle.visible = false;
                gameActive = true;
            } else if (bridgePlaced && gameActive) {
                // Interacción con el puente
                const tempMatrix = new THREE.Matrix4();
                tempMatrix.identity().extractRotation(controller.matrixWorld);
                raycaster.ray.origin.setFromMatrixPosition(controller.matrixWorld);
                raycaster.ray.direction.set(0, 0, -1).applyMatrix4(tempMatrix);

                const allSquares = bridge.children.filter(c => c.isSquare);
                const intersects = raycaster.intersectObjects(allSquares);

                if (intersects.length > 0) {
                    handleInteraction(intersects[0].object);
                }
            }
        }
        
        function setupBridge(parent) {
            const bridgeGroup = new THREE.Group();
            let squares = [];
            
            const squareSize = 0.5;
            const gap = 0.1;

            for (let i = 0; i < bridgeRows; i++) {
                const safeIndex = Math.round(Math.random());
                for (let j = 0; j < 2; j++) {
                    const geometry = new THREE.BoxGeometry(squareSize, 0.05, squareSize);
                    const material = new THREE.MeshStandardMaterial({ color: 0xffffff, transparent: true, opacity: 0.4, metalness: 0.1, roughness: 0.2 });
                    const square = new THREE.Mesh(geometry, material);
                    square.position.z = -(i * (squareSize + gap));
                    square.position.x = (j * (squareSize + gap)) - (squareSize / 2 + gap/2);
                    square.isSquare = true; // Custom property
                    square.isSafe = (j === safeIndex);
                    square.row = i;
                    bridgeGroup.add(square);
                    squares.push(square);
                }
            }
            return bridgeGroup;
        }

        function handleInteraction(clickedMesh) {
            if (clickedMesh.row === currentRow) {
                if (clickedMesh.isSafe) {
                    clickedMesh.material.color.setHex(0x00ff00);
                    clickedMesh.material.opacity = 0.9;
                    currentRow++;
                    if (currentRow >= bridgeRows) endGame(true);
                } else {
                    shatterSquare(clickedMesh);
                    endGame(false);
                }
            }
        }

        function shatterSquare(mesh) {
            mesh.visible = false;
            const numFragments = 16;
            const fragmentMaterial = new THREE.MeshStandardMaterial({ color: 0xffffff, metalness: 0.1, roughness: 0.5 });
            
            const worldPosition = new THREE.Vector3();
            mesh.getWorldPosition(worldPosition);

            for (let i = 0; i < numFragments; i++) {
                const fragmentGeometry = new THREE.BoxGeometry(0.1, 0.05, 0.1);
                const fragment = new THREE.Mesh(fragmentGeometry, fragmentMaterial);
                fragment.position.copy(worldPosition);
                const velocity = new THREE.Vector3((Math.random() - 0.5) * 0.5, Math.random() * 0.5, (Math.random() - 0.5) * 0.5);
                shatteredFragments.push({ mesh: fragment, velocity: velocity, lifetime: 120 });
                scene.add(fragment);
            }
        }

        function endGame(isWin) {
            gameActive = false;
            showMessage(isWin ? "¡Felicidades, has cruzado!" : "¡Juego Terminado! Has caído.", !isWin);
            setTimeout(() => window.location.reload(), 4000);
        }
        
        function render(timestamp, frame) {
            if (frame) {
                const referenceSpace = renderer.xr.getReferenceSpace();
                const session = renderer.xr.getSession();
                if (hitTestSourceRequested === false) {
                    session.requestReferenceSpace('viewer').then(referenceSpace => {
                        session.requestHitTestSource({ space: referenceSpace }).then(source => {
                            hitTestSource = source;
                        });
                    });
                    hitTestSourceRequested = true;
                }

                if (hitTestSource && !bridgePlaced) {
                    const hitTestResults = frame.getHitTestResults(hitTestSource);
                    if (hitTestResults.length) {
                        const hit = hitTestResults[0];
                        reticle.visible = true;
                        reticle.matrix.fromArray(hit.getPose(referenceSpace).transform.matrix);
                    } else {
                        reticle.visible = false;
                    }
                }
            }
            
            // Animar fragmentos
            for (let i = shatteredFragments.length - 1; i >= 0; i--) {
                const f = shatteredFragments[i];
                f.mesh.position.addScaledVector(f.velocity, 0.016);
                f.velocity.y -= 0.01; // Gravedad
                f.lifetime--;
                if (f.lifetime <= 0) {
                    scene.remove(f.mesh);
                    shatteredFragments.splice(i, 1);
                }
            }

            renderer.render(scene, camera);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        function showMessage(text, isError = false) { message.textContent = text; message.style.backgroundColor = isError ? 'rgba(200, 0, 0, 0.8)' : 'rgba(0,0,0,0.7)'; message.style.display = 'block'; }
    </script>
</body>
</html>

