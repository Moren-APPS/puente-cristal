<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Aventura de Manos en 3D</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <style>
        body { margin: 0; font-family: 'Press Start 2P', sans-serif; background-color: #5C94FC; overflow: hidden; }
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');
        #container { position: relative; width: 100vw; height: 100vh; display: flex; justify-content: center; align-items: center; }
        video, canvas { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%) scaleX(-1); max-width: 100%; max-height: 100%; border-radius: 10px; }
        canvas { background-color: transparent; }
        #gameCanvas { z-index: 1; }
        #webcam { z-index: 0; }
        #overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.8); color: white; display: flex; flex-direction: column; justify-content: center; align-items: center; text-align: center; z-index: 10; padding: 20px; box-sizing: border-box; }
        h1 { font-size: 2em; margin-bottom: 20px; text-shadow: 3px 3px #000; }
        p { max-width: 80%; line-height: 1.5; font-size: 1.2em; }
        button { padding: 15px 30px; font-size: 1.2em; background-color: #fbd000; color: #000; border: 4px solid #000; border-radius: 10px; cursor: pointer; font-weight: bold; font-family: 'Press Start 2P', sans-serif; }
        #loading { display: none; z-index: 5; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: white; font-size: 1.5em; background-color: rgba(0,0,0,0.7); padding: 20px; border-radius: 10px; }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>
    <div id="overlay">
        <h1>¡Aventura de Salto!</h1>
        <p>¡Corre hacia adelante y salta con tu mano para romper los bloques y aplastar enemigos!</p>
        <button id="startButton">Iniciar Juego</button>
    </div>
    <div id="container">
        <video id="webcam" playsinline></video>
        <canvas id="gameCanvas"></canvas>
        <div id="loading">Cargando modelos de IA...</div>
    </div>
    <script>
        const startButton = document.getElementById('startButton');
        const overlay = document.getElementById('overlay');
        const videoElement = document.getElementById('webcam');
        const gameCanvas = document.getElementById('gameCanvas');
        const gameCtx = gameCanvas.getContext('2d');
        const loadingElement = document.getElementById('loading');
        
        let hands, activeStream, handsInitialized = false;
        const smoothingFactor = 0.4;

        // --- ESTADO DEL JUEGO ---
        let player = null;
        let gameObjects = [];
        let score = 0;
        let objectSpawnTimer = 0;
        const PUNCH_VELOCITY_THRESHOLD = 5;

        // --- ESTADO DEL FONDO ---
        let groundY;
        let clouds = [];
        let hills = [];
        
        // --- Clase Base para Objetos del Juego ---
        class GameObject {
            constructor() {
                this.baseWidth = 80;
                this.baseHeight = 80;
                this.scale = 0.1; // Inicia pequeño
                this.horizonY = gameCanvas.height / 2.2;
                this.x = Math.random() * gameCanvas.width;
                this.y = this.horizonY;
                this.speed = 0.005 + Math.random() * 0.005; // Velocidad de escalado
                this.active = true;
            }

            update() {
                this.scale += this.speed;
                // Mueve el objeto hacia abajo a medida que crece
                this.y = this.horizonY + (this.scale * 150);
                if (this.y > gameCanvas.height + this.height) {
                    this.active = false;
                }
            }
            
            get currentWidth() { return this.baseWidth * this.scale; }
            get currentHeight() { return this.baseHeight * this.scale; }
            get currentX() { return this.x - this.currentWidth / 2; }
            get currentY() { return this.y - this.currentHeight / 2; }
        }

        // --- Clase para los Bloques ---
        class Block extends GameObject {
             draw() {
                const x = this.currentX;
                const y = this.currentY;
                const w = this.currentWidth;
                const h = this.currentHeight;

                gameCtx.fillStyle = '#D95E00';
                gameCtx.fillRect(x, y, w, h);
                gameCtx.strokeStyle = 'black';
                gameCtx.lineWidth = Math.max(1, 5 * this.scale);
                gameCtx.strokeRect(x, y, w, h);

                gameCtx.fillStyle = 'white';
                gameCtx.font = `bold ${40 * this.scale}px "Press Start 2P"`;
                gameCtx.textAlign = 'center';
                gameCtx.textBaseline = 'middle';
                gameCtx.fillText('?', x + w / 2, y + h / 2 + (5 * this.scale));
            }
        }

        // --- Clase para los Goombas ---
        class Goomba extends GameObject {
            constructor() {
                super();
                this.baseWidth = 80;
                this.baseHeight = 80;
                this.speed = 0.004 + Math.random() * 0.004; // Un poco más lento
            }
            draw() {
                const x = this.currentX;
                const y = this.currentY;
                const w = this.currentWidth;
                const h = this.currentHeight;

                // Cuerpo
                gameCtx.fillStyle = '#6B2E04'; // Marrón oscuro
                gameCtx.beginPath();
                gameCtx.moveTo(x + w * 0.1, y + h);
                gameCtx.bezierCurveTo(x, y + h * 0.4, x + w, y + h * 0.4, x + w * 0.9, y + h);
                gameCtx.closePath();
                gameCtx.fill();

                // Cabeza
                gameCtx.fillStyle = '#D95E00'; // Marrón claro
                gameCtx.beginPath();
                gameCtx.arc(x + w / 2, y + h * 0.5, w / 2, Math.PI, 2 * Math.PI);
                gameCtx.fill();
                
                // Ojos
                gameCtx.fillStyle = 'white';
                gameCtx.fillRect(x + w * 0.25, y + h * 0.4, w * 0.15, h * 0.2);
                gameCtx.fillRect(x + w * 0.6, y + h * 0.4, w * 0.15, h * 0.2);
                gameCtx.fillStyle = 'black';
                gameCtx.fillRect(x + w * 0.3, y + h * 0.45, w * 0.05, h * 0.1);
                gameCtx.fillRect(x + w * 0.65, y + h * 0.45, w * 0.05, h * 0.1);
            }
        }
        
        class Player {
            constructor(landmarks) {
                this.landmarks = landmarks;
                this.state = { isFirstFrame: true, smoothedPoint: { x: 0, y: 0 }, verticalVelocity: 0, lastY: 0 };
            }
            update(landmarks) { this.landmarks = landmarks; }
            process() {
                const indexKuckle = this.landmarks[5];
                const currentPoint = { x: indexKuckle.x * gameCanvas.width, y: indexKuckle.y * gameCanvas.height };
                if (this.state.isFirstFrame) {
                    this.state.smoothedPoint = { ...currentPoint };
                    this.state.lastY = currentPoint.y;
                    this.state.isFirstFrame = false;
                }
                this.state.smoothedPoint.x += (currentPoint.x - this.state.smoothedPoint.x) * smoothingFactor;
                this.state.smoothedPoint.y += (currentPoint.y - this.state.smoothedPoint.y) * smoothingFactor;
                this.state.verticalVelocity = this.state.smoothedPoint.y - this.state.lastY;
                this.state.lastY = this.state.smoothedPoint.y;
            }
            isPunching() { return this.state.verticalVelocity < -PUNCH_VELOCITY_THRESHOLD; }
            drawHand() {
                drawConnectors(gameCtx, this.landmarks, HAND_CONNECTIONS, { color: '#FFFFFF', lineWidth: 6 });
                drawConnectors(gameCtx, this.landmarks, HAND_CONNECTIONS, { color: '#00FF00', lineWidth: 4 });
                drawLandmarks(gameCtx, this.landmarks, { color: 'white', lineWidth: 2, radius: 4 });
            }
        }

        function isPointInsideRect(point, obj) {
             return point.x > obj.currentX && point.x < obj.currentX + obj.currentWidth && 
                    point.y > obj.currentY && point.y < obj.currentY + obj.currentHeight;
        }
        
        function initBackground() {
            groundY = gameCanvas.height * 0.75;
            for (let i = 0; i < 5; i++) {
                hills.push({ x: Math.random() * gameCanvas.width, y: groundY, r: 40 + Math.random() * 40 });
                clouds.push({ x: Math.random() * gameCanvas.width, y: 50 + Math.random() * 100, r: 20 + Math.random() * 20, speed: 0.2 + Math.random() * 0.3 });
            }
        }

        function drawBackground() {
            // Cielo
            gameCtx.fillStyle = '#5C94FC';
            gameCtx.fillRect(0, 0, gameCanvas.width, gameCanvas.height);
            
            // Nubes
            clouds.forEach(cloud => {
                cloud.x += cloud.speed;
                if(cloud.x > gameCanvas.width + cloud.r * 2) cloud.x = -cloud.r * 2;
                
                gameCtx.fillStyle = 'white';
                gameCtx.beginPath();
                gameCtx.arc(cloud.x, cloud.y, cloud.r, 0, Math.PI * 2);
                gameCtx.arc(cloud.x + cloud.r * 0.8, cloud.y, cloud.r * 0.8, 0, Math.PI * 2);
                gameCtx.arc(cloud.x - cloud.r * 0.8, cloud.y, cloud.r * 0.8, 0, Math.PI * 2);
                gameCtx.fill();
            });

            // Suelo
            gameCtx.fillStyle = '#008000'; // Verde
            gameCtx.fillRect(0, groundY, gameCanvas.width, gameCanvas.height - groundY);
        }

        function onResults(results) {
            gameCtx.save();
            gameCtx.clearRect(0, 0, gameCanvas.width, gameCanvas.height);
            
            drawBackground();

            objectSpawnTimer++;
            if (objectSpawnTimer > 120) {
                if (Math.random() > 0.4) gameObjects.push(new Block());
                else gameObjects.push(new Goomba());
                objectSpawnTimer = 0;
            }
            
            // Ordenar por escala para que los objetos más cercanos se dibujen al frente
            gameObjects.sort((a, b) => a.scale - b.scale);

            gameObjects.forEach(obj => {
                obj.update();
                obj.draw();
            });
            
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const handLandmarks = results.multiHandLandmarks[0];
                if (!player) player = new Player(handLandmarks);
                player.update(handLandmarks);
                player.process();
                player.drawHand();

                gameObjects.forEach(obj => {
                    if (obj.active && player.isPunching() && isPointInsideRect(player.state.smoothedPoint, obj)) {
                        obj.active = false;
                        score++;
                    }
                });
            } else {
                player = null;
            }
            
            gameObjects = gameObjects.filter(obj => obj.active);

            gameCtx.fillStyle = 'white';
            gameCtx.font = '36px "Press Start 2P"';
            gameCtx.textAlign = 'left';
            gameCtx.textBaseline = 'top';
            gameCtx.shadowColor = 'black';
            gameCtx.shadowBlur = 5;
            gameCtx.fillText(`Puntos: ${score}`, 20, 20);
            gameCtx.shadowBlur = 0;

            gameCtx.restore();
        }

        function resizeCanvases() {
            const videoWidth = videoElement.videoWidth;
            const videoHeight = videoElement.videoHeight;
            if (!videoWidth) return;
            gameCanvas.width = videoWidth;
            gameCanvas.height = videoHeight;
            initBackground();
        }
        
        async function startCamera() {
            loadingElement.style.display = 'block';
            if (activeStream) activeStream.getTracks().forEach(track => track.stop());
            const constraints = { video: { width: { ideal: 1280 }, height: { ideal: 720 }, facingMode: 'user' } };
            try {
                activeStream = await navigator.mediaDevices.getUserMedia(constraints);
                videoElement.srcObject = activeStream;
                videoElement.onloadedmetadata = () => {
                    videoElement.play();
                    loadingElement.style.display = 'none';
                    resizeCanvases();
                    if (!handsInitialized) {
                        hands = new Hands({ locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}` });
                        hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.6, minTrackingConfidence: 0.6 });
                        hands.onResults(onResults);
                        sendToHands();
                        handsInitialized = true;
                    }
                };
            } catch (err) {
                loadingElement.style.display = 'none';
                console.error("Error al iniciar la cámara:", err);
            }
        }
        
        async function sendToHands() {
            if (videoElement.readyState >= 3) {
                await hands.send({ image: videoElement });
            }
            requestAnimationFrame(sendToHands);
        }
        
        startButton.addEventListener('click', () => {
            overlay.style.display = 'none';
            startCamera();
        });
        
        window.addEventListener('resize', resizeCanvases);
    </script>
</body>
</html>