<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Pizarra Virtual (Versión Multijugador)</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <style>
        body { margin: 0; font-family: sans-serif; background-color: #222; overflow: hidden; }
        #container { position: relative; width: 100vw; height: 100vh; display: flex; justify-content: center; align-items: center; }
        video, canvas { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%) scaleX(-1); max-width: 100%; max-height: 100%; border-radius: 10px; }
        canvas { background-color: transparent; }
        #outputCanvas { z-index: 2; }
        #drawingCanvas { z-index: 1; }
        #webcam { z-index: 0; }
        #overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.8); color: white; display: flex; flex-direction: column; justify-content: center; align-items: center; text-align: center; z-index: 10; padding: 20px; box-sizing: border-box; }
        h1 { font-size: 1.5em; margin-bottom: 20px; }
        p { max-width: 80%; line-height: 1.5; }
        button { padding: 15px 30px; font-size: 1.2em; background-color: #007BFF; color: white; border: none; border-radius: 10px; cursor: pointer; font-weight: bold; }
        #loading { display: none; z-index: 5; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: white; font-size: 1.5em; background-color: rgba(0,0,0,0.7); padding: 20px; border-radius: 10px; }
        #switchCameraButton { display: none; position: absolute; bottom: 20px; right: 20px; z-index: 100; padding: 10px 15px; font-size: 1.5em; background-color: rgba(0, 0, 0, 0.5); border: 2px solid white; border-radius: 50%; cursor: pointer; }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>
    <div id="overlay">
        <h1>Pizarra Virtual Final</h1>
        <p>Usa los íconos para cambiar herramientas y colores. <br>¡Ahora pueden dibujar hasta dos personas a la vez!</p>
        <button id="startButton">Iniciar Pizarra</button>
    </div>
    <div id="container">
        <video id="webcam" playsinline></video>
        <canvas id="drawingCanvas"></canvas>
        <canvas id="outputCanvas"></canvas>
        <div id="loading">Cargando modelos de IA...</div>
        <button id="switchCameraButton">🔄</button>
    </div>
    <script>
        const startButton = document.getElementById('startButton');
        const overlay = document.getElementById('overlay');
        const videoElement = document.getElementById('webcam');
        const outputCanvas = document.getElementById('outputCanvas');
        const outputCtx = outputCanvas.getContext('2d');
        const drawingCanvas = document.getElementById('drawingCanvas');
        const drawingCtx = drawingCanvas.getContext('2d');
        const switchCameraButton = document.getElementById('switchCameraButton');
        const loadingElement = document.getElementById('loading');
        let hands, activeStream;
        let handsInitialized = false;
        const smoothingFactor = 0.4;
        const eraserSize = 60;
        let currentFacingMode = 'user';
        let touchCooldown = 0;
        let handStates = [];
        const paletteIcon = { x: 30, y: 30, width: 60, height: 60, emoji: '🎨' };
        const thicknessIcon = { x: 30, y: 110, width: 60, height: 60 };
        const clearButton = { x: 0, y: 30, width: 60, height: 60, emoji: '🗑️' };
        const colors = ['#FF1744', '#00E676', '#2979FF', '#FFFF00', '#FFFFFF', '#000000'];
        let isPaletteOpen = false;
        let colorSwatches = [];
        const thicknessOptions = [4, 10, 20];
        let currentLineWidth = 10;
        let isThicknessMenuOpen = false;
        let thicknessSwatches = [];
        
        function isPointInsideRect(point, rect) { return point.x > rect.x && point.x < rect.x + rect.width && point.y > rect.y && point.y < rect.y + rect.height; }
        
        function drawUI(ctx, point) { /* ... sin cambios ... */ }
        function drawPencilCursor(ctx, centerPos) { /* ... sin cambios ... */ }

        function onResults(results) {
            outputCtx.save();
            outputCtx.clearRect(0, 0, outputCanvas.width, outputCanvas.height);
            
            // Dibuja la UI una sola vez. Usa la primera mano para la interacción de hover.
            const interactionPoint = handStates[0]?.smoothedPoint || {x: -100, y: -100};
            drawUI(outputCtx, interactionPoint);

            if (results.multiHandLandmarks) {
                // Limpia los estados de las manos que ya no se detectan
                handStates.length = results.multiHandLandmarks.length;

                results.multiHandLandmarks.forEach((landmarks, index) => {
                    let state = handStates[index];
                    if (!state) {
                        state = handStates[index] = {
                            lastPosition: null, // Reemplaza isDrawing
                            isFirstFrame: true,
                            smoothedPoint: { x: 0, y: 0 },
                            smoothedMidpoint: { x: 0, y: 0 },
                            smoothedPencilTip: { x: 0, y: 0 }
                        };
                    }

                    drawConnectors(outputCtx, landmarks, HAND_CONNECTIONS, { color: '#00FF00', lineWidth: 5 });
                    drawLandmarks(outputCtx, landmarks, { color: '#FFFFFF', lineWidth: 2, radius: 3 });
                    
                    const indexTip = landmarks[8];
                    const thumbTip = landmarks[4];
                    const currentPoint = { x: indexTip.x * outputCanvas.width, y: indexTip.y * outputCanvas.height };
                    const midpointX = ((thumbTip.x + indexTip.x) / 2) * outputCanvas.width;
                    const midpointY = ((thumbTip.y + indexTip.y) / 2) * outputCanvas.height;

                    if (state.isFirstFrame) {
                        state.smoothedPoint.x = currentPoint.x; state.smoothedPoint.y = currentPoint.y;
                        state.smoothedMidpoint.x = midpointX; state.smoothedMidpoint.y = midpointY;
                        state.smoothedPencilTip.x = midpointX; state.smoothedPencilTip.y = midpointY;
                        state.isFirstFrame = false;
                    }

                    state.smoothedPoint.x += (currentPoint.x - state.smoothedPoint.x) * smoothingFactor;
                    state.smoothedPoint.y += (currentPoint.y - state.smoothedPoint.y) * smoothingFactor;
                    state.smoothedMidpoint.x += (midpointX - state.smoothedMidpoint.x) * smoothingFactor;
                    state.smoothedMidpoint.y += (midpointY - state.smoothedMidpoint.y) * smoothingFactor;

                    const pencilAngle = Math.PI / 4;
                    const pencilHalfLength = 90 / 2;
                    const rawTipX = state.smoothedMidpoint.x + pencilHalfLength * Math.cos(pencilAngle);
                    const rawTipY = state.smoothedMidpoint.y + pencilHalfLength * Math.sin(pencilAngle);
                    
                    state.smoothedPencilTip.x += (rawTipX - state.smoothedPencilTip.x) * smoothingFactor;
                    state.smoothedPencilTip.y += (rawTipY - state.smoothedPencilTip.y) * smoothingFactor;

                    let fingerOnUI = false;
                    if (touchCooldown > 0) touchCooldown--;
                    
                    if (isPaletteOpen) { for (const swatch of colorSwatches) { if (isPointInsideRect(state.smoothedPoint, swatch) && touchCooldown === 0) { drawingCtx.strokeStyle = swatch.color; isPaletteOpen = false; touchCooldown = 20; fingerOnUI = true; break; } } } else if (isThicknessMenuOpen) { for (const swatch of thicknessSwatches) { if (isPointInsideRect(state.smoothedPoint, swatch) && touchCooldown === 0) { currentLineWidth = swatch.size; drawingCtx.lineWidth = currentLineWidth; isThicknessMenuOpen = false; touchCooldown = 20; fingerOnUI = true; break; } } }
                    if (!fingerOnUI && touchCooldown === 0) { if (isPointInsideRect(state.smoothedPoint, clearButton)) { drawingCtx.clearRect(0, 0, drawingCanvas.width, drawingCanvas.height); touchCooldown = 20; fingerOnUI = true; } else if (isPointInsideRect(state.smoothedPoint, paletteIcon)) { isPaletteOpen = !isPaletteOpen; isThicknessMenuOpen = false; touchCooldown = 20; fingerOnUI = true; } else if (isPointInsideRect(state.smoothedPoint, thicknessIcon)) { isThicknessMenuOpen = !isThicknessMenuOpen; isPaletteOpen = false; touchCooldown = 20; fingerOnUI = true; } }
                    
                    if (!fingerOnUI) {
                        const pinched = isPinched(landmarks);
                        const openPalm = isOpenPalm(landmarks);
                        if (openPalm) {
                            drawingCtx.clearRect(state.smoothedPoint.x - eraserSize / 2, state.smoothedPoint.y - eraserSize / 2, eraserSize, eraserSize);
                            outputCtx.save();
                            const eraserBodyWidth = eraserSize; const eraserBodyHeight = eraserSize * 0.6;
                            const x = state.smoothedPoint.x - eraserBodyWidth / 2; const y = state.smoothedPoint.y - eraserBodyHeight / 2;
                            outputCtx.fillStyle = 'rgba(255, 105, 180, 0.8)';
                            outputCtx.fillRect(x, y, eraserBodyWidth, eraserBodyHeight);
                            outputCtx.strokeStyle = 'rgba(0, 0, 0, 0.8)';
                            outputCtx.lineWidth = 2;
                            outputCtx.strokeRect(x, y, eraserBodyWidth, eraserBodyHeight);
                            outputCtx.restore();
                            state.lastPosition = null;
                        } else if (pinched) {
                            // --- CAMBIO: Lógica de dibujo por segmentos ---
                            if (state.lastPosition) {
                                drawingCtx.beginPath();
                                drawingCtx.moveTo(state.lastPosition.x, state.lastPosition.y);
                                drawingCtx.lineTo(state.smoothedPencilTip.x, state.smoothedPencilTip.y);
                                drawingCtx.stroke();
                            }
                            state.lastPosition = { x: state.smoothedPencilTip.x, y: state.smoothedPencilTip.y };
                            drawPencilCursor(outputCtx, state.smoothedMidpoint);
                        } else {
                            state.lastPosition = null;
                        }
                    }
                });
            } else {
                handStates.forEach(state => state.isFirstFrame = true);
            }
            outputCtx.restore();
        }

        function resizeCanvases() { const videoWidth = videoElement.videoWidth; const videoHeight = videoElement.videoHeight; if (!videoWidth) return; outputCanvas.width = videoWidth; outputCanvas.height = videoHeight; drawingCanvas.width = videoWidth; drawingCanvas.height = videoHeight; clearButton.x = outputCanvas.width - clearButton.width - 30; drawingCtx.strokeStyle = drawingCtx.strokeStyle || '#00FFFF'; drawingCtx.lineWidth = currentLineWidth; drawingCtx.lineCap = 'round'; drawingCtx.lineJoin = 'round'; }
        
        async function startCamera(facingMode) {
            loadingElement.style.display = 'block';
            if (activeStream) { activeStream.getTracks().forEach(track => track.stop()); }
            const constraints = { video: { width: { ideal: 1280 }, height: { ideal: 720 }, facingMode: { exact: facingMode } } };
            try {
                const stream = await navigator.mediaDevices.getUserMedia(constraints);
                activeStream = stream;
                videoElement.srcObject = stream;
                videoElement.onloadedmetadata = () => {
                    videoElement.play();
                    loadingElement.style.display = 'none';
                    switchCameraButton.style.display = 'block';
                    resizeCanvases();
                    if (!handsInitialized) {
                        hands = new Hands({ locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}` });
                        hands.setOptions({
                            maxNumHands: 2,
                            modelComplexity: 1,
                            minDetectionConfidence: 0.7,
                            minTrackingConfidence: 0.7
                        });
                        hands.onResults(onResults);
                        sendToHands();
                        handsInitialized = true;
                    }
                };
            } catch (err) {
                loadingElement.style.display = 'none';
                console.error("Error al iniciar/cambiar de cámara:", err);
            }
        }
        
        async function sendToHands() { if (videoElement.readyState >= 3) { await hands.send({ image: videoElement }); } requestAnimationFrame(sendToHands); }
        function isPinched(landmarks) { const thumbTip = landmarks[4]; const indexTip = landmarks[8]; const distance = Math.hypot(thumbTip.x - indexTip.x, thumbTip.y - indexTip.y); return distance < 0.04; }
        function isOpenPalm(landmarks) { let extendedFingers = 0; const fingerTips = [8, 12, 16, 20]; const fingerPips = [6, 10, 14, 18]; for (let i = 0; i < fingerTips.length; i++) { if (landmarks[fingerTips[i]].y < landmarks[fingerPips[i]].y) { extendedFingers++; } } return extendedFingers >= 3; }
        
        startButton.addEventListener('click', () => { overlay.style.display = 'none'; startCamera(currentFacingMode); });
        switchCameraButton.addEventListener('click', () => { currentFacingMode = (currentFacingMode === 'user') ? 'environment' : 'user'; startCamera(currentFacingMode); });
        window.addEventListener('resize', resizeCanvases);
        function drawPencilCursor(ctx, centerPos) { const totalLength = 90; const halfLength = totalLength / 2; const pencilWidth = 14; const tipLength = 15; ctx.save(); ctx.translate(centerPos.x, centerPos.y); ctx.rotate(Math.PI / 4); const bodyStart = -halfLength + 15; const bodyLength = totalLength - 15 - tipLength; const tipStart = bodyStart + bodyLength; ctx.fillStyle = '#FFB6C1'; ctx.fillRect(-halfLength, -pencilWidth / 2, 15, pencilWidth); ctx.fillStyle = '#C0C0C0'; ctx.fillRect(bodyStart - 5, -pencilWidth / 2 - 1, 5, pencilWidth + 2); ctx.fillStyle = '#FFD700'; ctx.fillRect(bodyStart, -pencilWidth / 2, bodyLength, pencilWidth); ctx.fillStyle = '#D2B48C'; ctx.beginPath(); ctx.moveTo(tipStart, -pencilWidth / 2); ctx.lineTo(tipStart + tipLength, 0); ctx.lineTo(tipStart, pencilWidth / 2); ctx.closePath(); ctx.fill(); ctx.fillStyle = '#333333'; ctx.beginPath(); ctx.moveTo(tipStart + tipLength, 0); ctx.lineTo(tipStart + tipLength - 5, -2); ctx.lineTo(tipStart + tipLength - 5, 2); ctx.closePath(); ctx.fill(); ctx.restore(); }
        function drawUI(ctx, point) { const buttonBackgroundColor = 'rgba(0, 0, 0, 0.5)'; ctx.fillStyle = buttonBackgroundColor; ctx.fillRect(paletteIcon.x, paletteIcon.y, paletteIcon.width, paletteIcon.height); ctx.font = '40px sans-serif'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText(paletteIcon.emoji, paletteIcon.x + paletteIcon.width / 2, paletteIcon.y + paletteIcon.height / 2); ctx.fillStyle = buttonBackgroundColor; ctx.fillRect(thicknessIcon.x, thicknessIcon.y, thicknessIcon.width, thicknessIcon.height); ctx.fillStyle = 'white'; ctx.fillRect(thicknessIcon.x + 15, thicknessIcon.y + 15, 30, 3); ctx.fillRect(thicknessIcon.x + 15, thicknessIcon.y + 28, 30, 6); ctx.fillRect(thicknessIcon.x + 15, thicknessIcon.y + 45, 30, 9); ctx.fillStyle = buttonBackgroundColor; ctx.fillRect(clearButton.x, clearButton.y, clearButton.width, clearButton.height); ctx.font = '40px sans-serif'; ctx.fillText(clearButton.emoji, clearButton.x + clearButton.width / 2, clearButton.y + clearButton.height / 2); if (isPaletteOpen) { colorSwatches = []; colors.forEach((color, index) => { const swatch = { x: paletteIcon.x + (index + 1) * (paletteIcon.width + 10), y: paletteIcon.y, width: paletteIcon.width, height: paletteIcon.height, color: color }; colorSwatches.push(swatch); ctx.fillStyle = buttonBackgroundColor; ctx.fillRect(swatch.x, swatch.y, swatch.width, swatch.height); ctx.fillStyle = color; ctx.fillRect(swatch.x + 5, swatch.y + 5, swatch.width - 10, swatch.height - 10); if (isPointInsideRect(point, swatch)) { ctx.strokeStyle = 'cyan'; ctx.lineWidth = 4; ctx.strokeRect(swatch.x, swatch.y, swatch.width, swatch.height); } }); } if (isThicknessMenuOpen) { thicknessSwatches = []; thicknessOptions.forEach((size, index) => { const swatch = { x: thicknessIcon.x + (index + 1) * (thicknessIcon.width + 10), y: thicknessIcon.y, width: thicknessIcon.width, height: thicknessIcon.height, size: size }; thicknessSwatches.push(swatch); ctx.fillStyle = buttonBackgroundColor; ctx.fillRect(swatch.x, swatch.y, swatch.width, swatch.height); ctx.fillStyle = 'white'; ctx.beginPath(); ctx.arc(swatch.x + swatch.width / 2, swatch.y + swatch.height / 2, swatch.size, 0, 2 * Math.PI); ctx.fill(); if (isPointInsideRect(point, swatch)) { ctx.strokeStyle = 'cyan'; ctx.lineWidth = 4; ctx.strokeRect(swatch.x, swatch.y, swatch.width, swatch.height); } }); } }
    </script>
</body>
</html>