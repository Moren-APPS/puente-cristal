<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Reto Dalgona: Hand Tracking</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <style>
        body { margin: 0; font-family: 'Helvetica Neue', sans-serif; background-color: #0d0d0d; overflow: hidden; }
        #container { position: relative; width: 100vw; height: 100vh; display: flex; justify-content: center; align-items: center; }
        video { display: none; }
        #ar-canvas, #game-canvas { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); max-width: 100%; max-height: 100%; border-radius: 10px; }
        #ar-canvas { transform: translate(-50%, -50%) scaleX(-1); z-index: 1; }
        #game-canvas { z-index: 2; pointer-events: none; }
        #timer { position: absolute; top: 20px; right: 20px; font-size: 2em; color: white; text-shadow: 2px 2px 4px #000; z-index: 30; display: none; }
        #overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.8); color: white; display: flex; flex-direction: column; justify-content: center; align-items: center; text-align: center; z-index: 100; padding: 20px; box-sizing: border-box; }
        .content { background-color: rgba(20, 20, 20, 0.9); padding: 30px; border-radius: 15px; box-shadow: 0 0 20px rgba(255, 165, 0, 0.5); border: 1px solid rgba(255, 165, 0, 0.7); max-width: 90%; }
        h1 { font-size: 2.5em; margin-bottom: 10px; color: #FFA500; text-shadow: 0 0 10px #FFA500; }
        button { padding: 12px 24px; font-size: 1.1em; background-color: #FFA500; color: #0d0d0d; border: none; border-radius: 10px; cursor: pointer; text-transform: uppercase; font-weight: bold; margin: 5px; transition: transform 0.2s; }
        button:hover { transform: scale(1.05); }
        #loading, #errorMessage { display: none; color: white; font-size: 1.2em; margin-top: 20px; }
        #errorMessage { color: #f87171; }
        .camera-select button { background-color: #333; color: white; border: 1px solid #555; }
        .camera-select button.selected { background-color: #FFA500; color: #0d0d0d; }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>
    <div id="overlay">
        <div class="content">
            <h1>Reto Dalgona</h1>
            <p>Usa tu dedo índice para cortar la galleta.</p>
            <div class="camera-select" style="margin: 20px 0;">
                <p style="margin-bottom: 10px;">Elige tu cámara:</p>
                <button id="btn-front-cam" class="selected">Frontal</button>
                <button id="btn-back-cam">Trasera</button>
            </div>
            <p>Elige una forma para empezar:</p>
            <div id="shape-selector">
                <button id="btn-triangle">Triángulo</button>
                <button id="btn-star">Estrella</button>
                <button id="btn-umbrella">Paraguas</button>
            </div>
             <div id="loading">Iniciando cámara...</div>
             <p id="errorMessage"></p>
        </div>
    </div>
    
    <div id="container">
        <video id="webcam" playsinline></video>
        <canvas id="ar-canvas"></canvas>
        <canvas id="game-canvas"></canvas>
    </div>
    <div id="timer">60</div>

    <script>
        // --- Elementos del DOM ---
        const overlay = document.getElementById('overlay');
        const videoElement = document.getElementById('webcam');
        const arCanvas = document.getElementById('ar-canvas');
        const arCtx = arCanvas.getContext('2d');
        const gameCanvas = document.getElementById('game-canvas');
        const gameCtx = gameCanvas.getContext('2d');
        const loadingElement = document.getElementById('loading');
        const errorElement = document.getElementById('errorMessage');
        const timerElement = document.getElementById('timer');

        // --- Variables de estado del juego ---
        let hands, animationFrameId;
        let gameActive = false, timerInterval, timeLeft = 60, isTracing = false;
        let selectedFacingMode = 'user'; // 'user' para frontal, 'environment' para trasera

        // --- Asignación de Eventos ---
        document.getElementById('btn-front-cam').onclick = () => selectCamera('user');
        document.getElementById('btn-back-cam').onclick = () => selectCamera('environment');
        document.getElementById('btn-triangle').onclick = () => startGame('triangle');
        document.getElementById('btn-star').onclick = () => startGame('star');
        document.getElementById('btn-umbrella').onclick = () => startGame('umbrella');

        function selectCamera(mode) {
            selectedFacingMode = mode;
            document.getElementById('btn-front-cam').classList.toggle('selected', mode === 'user');
            document.getElementById('btn-back-cam').classList.toggle('selected', mode === 'environment');
            // Al cambiar de cámara, la escala de la imagen se invierte o no
            arCanvas.style.transform = `translate(-50%, -50%) ${mode === 'user' ? 'scaleX(-1)' : ''}`;
        }
        
        // --- Lógica de Dibujo Vectorial ---
        function drawShape(ctx, shape, size) {
            const center = size / 2;
            ctx.clearRect(0, 0, size, size);
            // Dibujar galleta de fondo semi-transparente
            ctx.fillStyle = 'rgba(240, 194, 123, 0.75)';
            ctx.beginPath();
            ctx.arc(center, center, size * 0.45, 0, Math.PI * 2);
            ctx.fill();
            // Dibujar contorno de la forma
            ctx.strokeStyle = 'rgba(191, 123, 40, 0.85)';
            ctx.lineWidth = size * 0.02;
            ctx.beginPath();

            switch (shape) {
                case 'triangle':
                    const triRadius = size * 0.25;
                    ctx.moveTo(center, center - triRadius);
                    ctx.lineTo(center + triRadius * Math.cos(Math.PI / 6), center + triRadius * Math.sin(Math.PI / 6));
                    ctx.lineTo(center - triRadius * Math.cos(Math.PI / 6), center + triRadius * Math.sin(Math.PI / 6));
                    ctx.closePath();
                    break;
                case 'star':
                    const spikes = 5, outerRadius = size * 0.25, innerRadius = size * 0.1;
                    let rot = Math.PI / 2 * 3;
                    let x = center, y = center;
                    let step = Math.PI / spikes;
                    ctx.moveTo(center, center - outerRadius);
                    for (let i = 0; i < spikes; i++) {
                        x = center + Math.cos(rot) * outerRadius;
                        y = center + Math.sin(rot) * outerRadius;
                        ctx.lineTo(x, y);
                        rot += step;
                        x = center + Math.cos(rot) * innerRadius;
                        y = center + Math.sin(rot) * innerRadius;
                        ctx.lineTo(x, y);
                        rot += step;
                    }
                    ctx.closePath();
                    break;
                case 'umbrella':
                    const umbRadius = size * 0.2;
                    ctx.arc(center, center, umbRadius, Math.PI, 0);
                    ctx.moveTo(center, center);
                    ctx.lineTo(center, center + umbRadius * 1.5);
                    ctx.moveTo(center, center + umbRadius * 1.5);
                    ctx.arc(center - umbRadius * 0.2, center + umbRadius * 1.5, umbRadius * 0.2, 0, Math.PI / 2);
                    break;
            }
            ctx.stroke();
        }
        
        function drawCrack() {
            const ctx = gameCtx;
            const size = gameCanvas.width;
            ctx.clearRect(0,0,size,size);
            ctx.strokeStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.lineWidth = 3;
            for(let i = 0; i < 7; i++){
                ctx.beginPath();
                ctx.moveTo(size/2, size/2);
                ctx.lineTo(Math.random() * size, Math.random() * size);
                ctx.stroke();
            }
        }

        // --- Lógica de MediaPipe y Cámara ---
        function onResults(results) {
            if (loadingElement.style.display !== 'none') {
                loadingElement.style.display = 'none';
                document.getElementById('game-ui').style.display = 'flex';
                timerElement.style.display = 'block';
            }

            arCanvas.width = videoElement.videoWidth;
            arCanvas.height = videoElement.videoHeight;
            
            arCtx.save();
            arCtx.clearRect(0, 0, arCanvas.width, arCanvas.height);
            arCtx.drawImage(videoElement, 0, 0, arCanvas.width, arCanvas.height);
            
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const landmarks = results.multiHandLandmarks[0];
                drawConnectors(arCtx, landmarks, HAND_CONNECTIONS, { color: 'rgba(0, 255, 0, 0.5)', lineWidth: 5 });
                
                const indexFingerTip = landmarks[8]; // Punto 8 es la punta del dedo índice
                
                const arCanvasRect = arCanvas.getBoundingClientRect();
                const gameContainerRect = document.querySelector('.game-container').getBoundingClientRect();

                // Coordenadas del dedo en la vista de la cámara (0.0 a 1.0)
                // Invertimos X si la cámara es frontal
                const fingerX_norm = selectedFacingMode === 'user' ? 1 - indexFingerTip.x : indexFingerTip.x;
                const fingerY_norm = indexFingerTip.y;
                
                // Mapear coordenadas de la cámara al contenedor del juego
                const x_game = (fingerX_norm * arCanvasRect.width) - gameContainerRect.left;
                const y_game = (fingerY_norm * arCanvasRect.height) - gameContainerRect.top;

                checkCut(x_game, y_game);
            } else {
                 isTracing = false;
            }
            arCtx.restore();
        }
        
        async function startGame(shape) {
            overlay.querySelector('.content').style.display = 'none';
            loadingElement.style.display = 'block';

            try {
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: { width: 1280, height: 720, facingMode: selectedFacingMode }
                });
                videoElement.srcObject = stream;
                
                videoElement.onloadedmetadata = () => {
                    videoElement.play();
                    
                    const gameContainerSize = document.querySelector('.game-container').offsetWidth;
                    gameCanvas.width = gameContainerSize;
                    gameCanvas.height = gameContainerSize;
                    drawShape(gameCtx, shape, gameContainerSize);

                    if (!hands) {
                        hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
                        hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
                        hands.onResults(onResults);
                    }

                    sendToHands();
                    
                    timeLeft = 60;
                    timerElement.textContent = timeLeft;
                    gameActive = true;
                    timerInterval = setInterval(updateTimer, 1000);
                };

            } catch (err) {
                loadingElement.style.display = 'none';
                overlay.querySelector('.content').style.display = 'block';
                errorElement.style.display = 'block';
                errorElement.textContent = `Error: ${err.message}. Asegúrate de dar permiso a la cámara.`;
            }
        }
        
        async function sendToHands() {
            if (gameActive && !videoElement.paused && !videoElement.ended) {
                await hands.send({ image: videoElement });
            }
            if(gameActive) {
                animationFrameId = requestAnimationFrame(sendToHands);
            }
        }

        function checkCut(x, y) {
            if (!gameActive) return;

            const pixelData = gameCtx.getImageData(x, y, 1, 1).data;
            const isOnPath = pixelData[3] > 0;

            if (!isOnPath && isTracing) {
                endGame(false);
            } else if (isOnPath) {
                if (!isTracing) {
                    isTracing = true;
                }
            }
        }

        function updateTimer() {
            if (!gameActive) return;
            timeLeft--;
            timerElement.textContent = timeLeft;
            if (timeLeft <= 0) {
                endGame(false);
            }
        }

        function endGame(isWin) {
            if (!gameActive) return;
            
            gameActive = false;
            clearInterval(timerInterval);
            cancelAnimationFrame(animationFrameId);
            
            const contentDiv = overlay.querySelector('.content');
            const h1 = contentDiv.querySelector('h1');
            const p = contentDiv.querySelector('p');
            
            contentDiv.style.display = 'block';

            if (isWin) {
                h1.textContent = "¡Felicidades!";
                p.textContent = "Has cortado la galleta a la perfección.";
            } else {
                drawCrack();
                h1.textContent = "¡Has Perdido!";
                p.textContent = "La galleta se ha roto.";
            }
            
            overlay.querySelector('#shape-selector').innerHTML = '<button onclick="window.location.reload()">Jugar de Nuevo</button>';
            overlay.style.display = 'flex';
        }
    </script>
</body>
</html>

