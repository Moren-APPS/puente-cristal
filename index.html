<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Hand Tracking: Grab & Drop Demo</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <style>
        body { margin: 0; font-family: sans-serif; background-color: #111; color: white; overflow: hidden; }
        #container { position: relative; width: 100vw; height: 100vh; }
        video { display: none; }
        .output_canvas { width: 100%; height: 100%; object-fit: contain; transform: scaleX(-1); }
        .loading, #overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: flex; flex-direction: column; justify-content: center; align-items: center; text-align: center; background-color: rgba(0,0,0,0.8); z-index: 100; }
        #loading { display: none; }
        #info { position: absolute; top: 10px; width: 100%; text-align: center; z-index: 50; font-size: 1.2em; text-shadow: 1px 1px 2px black; }
        button { padding: 15px 30px; font-size: 1.2em; background-color: #007BFF; color: white; border: none; border-radius: 10px; cursor: pointer; font-weight: bold; }
        #errorMessage { color: #f87171; margin-top: 20px; max-width: 80%; }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>

<body>
  <div id="overlay">
    <h1>Prueba de Agarrar y Soltar</h1>
    <p>Presiona el botón para iniciar la cámara.</p>
    <button id="startButton">Iniciar Detección</button>
    <p id="errorMessage"></p>
  </div>

  <div id="info" style="display: none;">Junta el pulgar y el índice para agarrar el cubo.</div>
  <div class="container">
    <video id="webcam" playsinline></video>
    <canvas id="outputCanvas" width="1280px" height="720px"></canvas>
    <div id="loading"><p>Cargando modelos de IA...</p></div>
  </div>

  <script>
    const videoElement = document.getElementById('webcam');
    const canvasElement = document.getElementById('outputCanvas');
    const canvasCtx = canvasElement.getContext('2d');
    const loadingElement = document.querySelector('.loading');
    const startButton = document.getElementById('startButton');
    const overlay = document.getElementById('overlay');
    const infoElement = document.getElementById('info');
    const errorElement = document.getElementById('errorMessage');
    
    let hands, animationFrameId;
    let isGrabbing = false;
    let cube = { x: 300, y: 300, size: 80, color: '#007BFF' };

    function onResults(results) {
      if (loadingElement.style.display !== 'none') {
        loadingElement.style.display = 'none';
        infoElement.style.display = 'block';
      }

      canvasElement.width = videoElement.videoWidth;
      canvasElement.height = videoElement.videoHeight;
      
      canvasCtx.save();
      canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
      canvasCtx.drawImage(videoElement, 0, 0, canvasElement.width, canvasElement.height);
      
      canvasCtx.fillStyle = cube.color;
      canvasCtx.fillRect(cube.x - cube.size / 2, cube.y - cube.size / 2, cube.size, cube.size);

      if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
        const landmarks = results.multiHandLandmarks[0];
        const thumbTip = landmarks[4];
        const indexTip = landmarks[8];
        
        const fingerDistance = Math.hypot((indexTip.x - thumbTip.x) * canvasElement.width, (indexTip.y - thumbTip.y) * canvasElement.height);
        const isPinched = fingerDistance < 40; 

        const indexTipX = indexTip.x * canvasElement.width;
        const indexTipY = indexTip.y * canvasElement.height;
        
        const distToCube = Math.hypot(indexTipX - cube.x, indexTipY - cube.y);
        
        if (isPinched && !isGrabbing && distToCube < cube.size) {
            isGrabbing = true;
            cube.color = '#FFD700'; 
        } else if (!isPinched) {
            if (isGrabbing) {
                isGrabbing = false;
                cube.color = '#007BFF'; 
            }
        }

        if (isGrabbing) {
            cube.x = indexTipX;
            cube.y = indexTipY;
        }

        canvasCtx.beginPath();
        canvasCtx.arc(indexTipX, indexTipY, 15, 0, 2 * Math.PI);
        canvasCtx.fillStyle = isGrabbing ? 'rgba(255, 215, 0, 0.8)' : 'rgba(255, 0, 0, 0.5)';
        canvasCtx.fill();
        canvasCtx.strokeStyle = 'white';
        canvasCtx.lineWidth = 2;
        canvasCtx.stroke();
      } else {
        if (isGrabbing) {
            isGrabbing = false;
            cube.color = '#007BFF';
        }
      }
      canvasCtx.restore();
    }

    async function startApp() {
        overlay.style.display = 'none';
        loadingElement.style.display = 'block';

        try {
            const stream = await navigator.mediaDevices.getUserMedia({
                video: { width: 1280, height: 720, facingMode: 'user' }
            });
            videoElement.srcObject = stream;
            
            videoElement.onloadedmetadata = () => {
                videoElement.play();
                
                if (!hands) {
                    hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
                    hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
                    hands.onResults(onResults);
                }
                
                sendToHands();
            };

        } catch (err) {
            loadingElement.style.display = 'none';
            overlay.style.display = 'flex';
            errorElement.textContent = `Error al iniciar la cámara: ${err.message}. Asegúrate de haber dado permiso.`;
            console.error(err);
        }
    }

    async function sendToHands() {
        if (!videoElement.paused && !videoElement.ended) {
            await hands.send({ image: videoElement });
        }
        animationFrameId = requestAnimationFrame(sendToHands);
    }

    startButton.addEventListener('click', startApp);

  </script>
</body>
</html>

